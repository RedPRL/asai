module type S =
sig
  module Code : Code.S
  module Phase : Phase.S

  (** [messagef ~loc ~additional_marks ~code format ...] constructs a diagnostic along with the backtrace frames recorded via [tracef]. *)
  val messagef : ?loc:Span.t -> ?additional_marks:Span.t list -> ?severity:Severity.t -> code:Code.t -> ('a, Format.formatter, unit, (Code.t, Phase.t) Diagnostic.t) format4 -> 'a

  (** [kmessagef kont ~loc ~additional_marks ~code format ...] constructs a diagnostic and then apply [kont] to the resulting diagnostic. *)
  val kmessagef : ((Code.t, Phase.t) Diagnostic.t -> 'b) -> ?loc:Span.t -> ?additional_marks:Span.t list -> ?severity:Severity.t -> code:Code.t -> ('a, Format.formatter, unit, 'b) format4 -> 'a

  (** [tracef ~loc format ...] record a frame. *)
  val tracef : ?loc:Span.t -> Phase.t -> ('a, Format.formatter, unit, (unit -> 'b) -> 'b) format4 -> 'a

  (** [append_marks msg marks] appends [marks] to the additional marks of [msg]. *)
  val append_marks : (Code.t, Phase.t) Diagnostic.t -> Span.t list -> (Code.t, Phase.t) Diagnostic.t

  (** Emit a diagnostic and continue the computation. *)
  val emit : (Code.t, Phase.t) Diagnostic.t -> unit

  (** [emitf ~loc ~additional_marks ~code format ...] constructs and emits a diagnostic. *)
  val emitf : ?loc:Span.t -> ?additional_marks:Span.t list -> ?severity:Severity.t -> code:Code.t -> ('a, Format.formatter, unit, unit) format4 -> 'a

  (** Emit a diagnostic and abort the computation. *)
  val fatal: (Code.t, Phase.t) Diagnostic.t -> 'a

  (** [fatalf ~loc ~additional_marks ~code format ...] constructs a diagnostic and abort the current computation. *)
  val fatalf : ?loc:Span.t -> ?additional_marks:Span.t list -> ?severity:Severity.t -> code:Code.t -> ('a, Format.formatter, unit, 'b) format4 -> 'a

  (** [run ~emit ~fatal f] runs the thunk [f], using [emit] to handle emitted diagnostics before continuing
      the computation, and [fatal] to handle diagnostics after aborting the computation. *)
  val run : ?init_backtrace:(Phase.t * Diagnostic.message Span.located) Bwd.bwd
    -> emit:((Code.t, Phase.t) Diagnostic.t -> unit) -> fatal:((Code.t, Phase.t) Diagnostic.t -> 'a) -> (unit -> 'a) -> 'a

  (** [bridge m run f] runs the thunk [f] that uses different error codes, using the runner [run] that is intended
      to a different instance of {!val:run} with a different {!module:Code}. The diagnostics [d] generated by [f]
      are transformed into [m d] before being adapted.

      Here shows a typical use:
      {[
        module M1 = Logger.Make(Code1)
        module M2 = Logger.Make(Code2)

            M1.bridge (Diagnostic.map code_mapper) M2.run @@ fun () -> ...
      ]}
  *)
  val bridge :
    (('code,'phase) Diagnostic.t -> (Code.t, Phase.t) Diagnostic.t) ->
    (?init_backtrace:(Phase.t * Diagnostic.message Span.located) Bwd.bwd ->
     emit:(('code,'phase) Diagnostic.t -> unit) -> fatal:(('code,'phase) Diagnostic.t -> 'a) -> (unit -> 'a) -> 'a) ->
    (unit -> 'a) -> 'a

  (** [try_with ~emit ~fatal f] runs the thunk [f], using [emit] to intercept emitted diagnostics before continuing
      the computation, and [fatal] to intercept diagnostics after aborting the computation. The default interceptors
      reperform or reraise the intercepted diagnostics. *)
  val try_with : ?emit:((Code.t, Phase.t) Diagnostic.t -> unit) -> ?fatal:((Code.t, Phase.t) Diagnostic.t -> 'a) -> (unit -> 'a) -> 'a
end
