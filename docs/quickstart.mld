{0 Quickstart Tutorial}

This tutorial is for an implementer (you!) to adopt this library as quickly as possible. We will assume you are already familiar with OCaml and are using a typical OCaml package structure.

{1 Define Error Codes}

The first step is to create a file [Logger.ml] with the following template:

{[
module Code =
struct
  (** All message codes used in your application. *)
  type t = (* ... *)

  (** The default severity of messages with a particular message code. *)
  let default_severity : t -> Asai.Diagnostic.severity =
    function
    | (* ... *) -> Bug
    | (* ... *) -> Error
    | (* ... *) -> Warning

  (** A short, concise, ideally Google-able string representation for each message code. *)
  let to_string : t -> string =
    function
    | (* ... *) -> "E0001"
    | (* ... *) -> "E0002"
end

(** Include all the goodies from the asai library. *)
include Asai.Logger.Make(Code)
]}

The most important step is to decide the {i message codes}. It should be a meaningful classification of all the messages that could be sent to the end users. For example, [UndefinedSymbol] could be a reasonable code for a message about failing to find the definition of a symbol. Once you define the type of all message codes, you will have to define two functions [default_severity] and [to_string]:

+ [default_severity]: {i Severity} means how serious an end user should take your message (is it an error or a warning?), and this can be overwritten when a message is sent. It seems messages with the same message code usually come with the same severity, so we want you to define a default severity value for each message code. You can then save some typing later when sending a message.
+ [to_string]: This function is to show the message code to the user. Ideally, it should give a short, Google-able string representation. Please do not use long descriptions such as "scope-error: undefined symbols." The library will give you plenty of opportunities to add as many details as you want to a message, but not here. The message code should be unambiguous, easily recognizable, and "machine-readable without ChatGPT."

Once you have filled out the template, run [dune build] or other tools to check that everything compiles. If so, you are ready for the next step.

{1 Start Sending Messages}

Now, go to the places where you want to send a message to end users, be it a warning or an error. If you want to print a message and continue the execution, you can {{!val:Asai.Logger.S.emit}emit} a string:
{[
Logger.emit Greeting "Hello!";
(* continue doing other things *)
]}
where [Greeting] is the message code of this message. The fancier version is {{!val:Asai.Logger.S.emitf}emitf}, which formats a message like [printf] and sends it:
{[
Logger.emitf TypeError "@[<2>This term doesn't look right:@ %a@]" Syntax.pp term;
(* continue doing other things *)
]}
There is an important limitation of {{!val:Asai.Logger.S.emitf}emitf} though: you should not include {i any} control character (for example the newline character [\n]) {i anywhere} when using {{!val:Asai.Logger.S.emitf}emitf}. Use break hints (such as [@,] and [@ ]) and boxes instead. See {!module:Stdlib.Format} for more information on boxes and break hints.

If you wish to terminate your program after sending a message instead of continuing the execution, use {{!val:Asai.Logger.S.fatal}fatal} instead of {{!val:Asai.Logger.S.emit}emit}. There's also a fancier {{!val:Asai.Logger.S.fatalf}fatalf} that works in the same way as {{!val:Asai.Logger.S.emitf}emitf}.

{1 Choose a Backend}

Now your program is generating lots of messages, and you have to choose a {i backend} to handle them. We will show how to display those messages in a terminal. Suppose your entry point module looks like this:
{[
let () = (* your application code *)
]}
You can use the {{!module:Asai.Tty}terminal} backend as follows:
{[
module Term = Asai.Tty.Make (Logger.Code)

let () =
  Logger.run ~emit:Term.display ~fatal:Term.display @@ fun () ->
  (* your application code *)
]}

{1 Add Backtraces}

Great messages come with meaningful backtraces. To add backtraces, you will have to "annotate" your code to generate meaningful stack frames. Suppose this is one of the functions whose invocation should be noted in user-facing backtraces:
{[
let f x y =
  (* very important code *)
]}
Add {{!val:Asai.Logger.S.trace}trace} to add a frame to the current backtrace:
{[
let f x y =
  Logger.trace "When calling f..." @@ fun () ->
  (* very important code *)
]}
Similar to {{!val:Asai.Logger.S.emitf}emitf}, there is also {{!val:Asai.Logger.S.tracef}tracef} which allows you to format messages:
{[
let f x y =
  Logger.tracef "When calling f on %d and %d..." x y @@ fun () ->
  (* very important code *)
]}

Note that, by default, the terminal backend will not show backtraces. You have to enable it as follows in your entry-point module:
{[
module Term = Asai.Tty.Make (Logger.Code)

let () =
  Logger.run
    ~emit:(Term.display ~show_backtrace:true)
    ~fatal:(Term.display ~show_backtrace:true) @@ fun () ->
  (* your application code *)
]}

We do not recommend adding {{!val:Asai.Logger.S.trace}trace} to every single function. Remember that they have to make sense to end users!

{1 Add Location Information}

Good messages also help end users locate the issues in their program or proof. Here, a {i location} is a range of text from a file, which we call {i span.} Many functions in your [Logger] take an optional location argument [loc], including {{!val:Asai.Logger.S.trace}trace}, which should be a span highlighting the most relevant text. For example, maybe the term which does not type check should be highlighted. The asai library will take the location information and draw fancy Unicode art on the screen to highlight the text. Here is one snippet showing the usage:
{[
Logger.emit ~loc Greeting "Hello again!";
(* continue doing other things *)
]}
You can use {{!val:Asai.Span.make}Span.make} to create such a span manually. However, if you are using ocamllex and Menhir, you certainly want to use provided helper functions. One of them is {{!val:Asai.Span.make}Span.locate}; you can add these lines in your Menhir grammar to generated a node annotated with its location:
{v
%inline
locate(X):
  | e = X
    { Asai.Span.locate_lex $loc e }
v}
The annotated node will have type {{!type:Asai.Span.located}[data] Span.located} where [data] is the output type of [X]. Another one is {{!val:Asai.Span.of_lexbuf}Span.of_lexbuf}, which comes in handy when reporting a parsing error:
{[
try Grammar.start Lex.token lexbuf with
| Lex.SyntaxError token ->
  Logger.fatalf ~loc:(Span.of_lexbuf lexbuf) ParsingError
    {|Unrecognized token "%s"|} String.escaped token
| Grammar.Error ->
  Logger.fatal ~loc:(Span.of_lexbuf lexbuf) ParsingError
    "Could not parse the program"
]}
Please take a look at {!module:Asai.Span} to learn all kinds of ways to create a span!

Note that [Logger] will remember and reuse the innermost specified location, and thus you do not have to explicitly pass it. For example, in the following code
{[
Logger.trace ~loc "When checking this code..." @@ fun () ->
(* ... *)
Logger.emit "Wow!" (* using the location [loc] from above *)
(* ... *)
]}
the inner message ["Wow!"] will inherit the location [loc] from the outer {{!val:Asai.Logger.S.trace}trace} function call! You can also use {{!val:Asai.Logger.S.merge_loc}merge_loc} to "remember" a location for later use, which is helpful when you want to remember a location but not to leave a trace:
{[
Logger.merge_loc (Some loc) @@ fun () ->
(* ... *)
Logger.emit "Wow!" (* using the location [loc] from above *)
(* ... *)
]}
Of course, you can always pass a new location to overwrite the remembered one:
{[
Logger.merge_loc (Some loc) @@ fun () ->
(* ... *)
Logger.emit ~loc:real_loc "Wow!" (* using [real_loc] instead  *)
(* ... *)
]}

{1 Use a Library that Uses asai}

ðŸš§ We are still writing this part...

{1 There are More!}

We are still expanding this tutorial, but in the meanwhile, you can also check out our {{!module:Asai} ðŸ“” API reference}.
