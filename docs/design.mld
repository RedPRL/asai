{0 Design Principles}

{1 Four Factors of a Diagnostic}

In addition to the main message, the API should allow implementers to easily specify the following four factors, and they are somewhat independent.

+ {b Whether the program terminate now.} This is done by the choice between {!val:Asai.Logger.S.emitf} for non-fatal messages and {!val:Asai.Logger.S.fatalf} for fatal ones.
+ {b How the user should classify the message.} See {!type:Asai.Diagnostic.severity}.
+ {b A succinct Google-able message code.} While severity should be changeable independently of the message code, often the same code implies the same severity. That is why we have {!val:Asai.Diagnostic.Code.default_severity} to specify the default severity for each code.
+ {b The backtrace and locations of other related text.} See {!val:Asai.Logger.S.tracef} and {!field:Asai.Diagnostic.additional_messages}.

{1 Stable Unicode Art Must Avoid Column Numbers}

There is a long history of using ASCII printable characters and ANSI escape sequences, and recently also non-ASCII Unicode characters, to draw pictures on terminals. To display compiler diagnostics, this technique has been used to assemble line numbers, code highlighting, and other pieces of information in a visually pleasing way. Non-ASCII Unicode characters greatly expand the vocabulary of ASCII art, and we will call the new art form {i Unicode art} to signify the use of non-ASCII characters. However, these Unicode characters also impose new challenges as their visual widths are unpredictable without knowing the exact terminal (emulator), the exact font, etc. Unicode emoji sequences might be one of the challenging cases: a pirate flag (üè¥‚Äç‚ò†Ô∏è)  may be shown as a single flag on supported platforms but as a black flag (üè¥) and a skull (‚ò†Ô∏è) on other platforms. This means its visual width is unpredictable. (See {{: https://unicode.org/reports/tr51/#Display}UTS #51 Section 2.2}.) The rainbow flag (üè≥Ô∏è‚Äçüåà), skin tones, and many other emoji sequences have the same issue. Other less chaotic but still challenging cases include {{: https://util.unicode.org/UnicodeJsps/list-unicodeset.jsp?a=[:ea=A:]}characters whose East Asian width is Ambiguous.}

It is thus wise to avoid emoji sequences and other tricky cases in Unicode art. To quantify the degree to which a Unicode art can remain visually pleasing under different platforms, we specify the following four levels of stability. Note that the end users may choose to include tricky characters in their proofs or programs, and the Unicode art must remain visually pleasing no matter what is used by the end user.

- {b Level 0 (the least stable):} Assume every character occupies the same width. Thanks to the popularity of Unicode, programs of this level are mostly considered outdated.

- {b Level 1:} Use heuristics (such as various implementations of [wcwidth] and [wcswidth]) to predict the visual width of a string. These heuristics are created to help programmers handle more characters, in particular CJK characters, without dramatically changing the code. They however do not solve the core problem (that is, visual width is fundamentally ill-defined) and they often could not handle tricky cases such as emoji sequences at all. Many compilers are at this level.

- {b Level 2a:} Stability under very limited assumptions on which characters should have the same widths. For example, if an ASCII art only assumes Unicode box-drawing characters are of the same width (which is the case in all conceivable situations), then it satisfies this level. However, the phrase "very limited" is somewhat subjective, and thus we present a more specific version below.

- {b Level 2b:} Stability under only theses assumptions:
  {ul
    {- {{: https://util.unicode.org/UnicodeJsps/list-unicodeset.jsp?a=[:ea=F:]|[:ea=W:]}All the characters whose East Asian width is either Fullwidth or Wide} have the same width (as long as they are not used as part of an emoji sequence).}
    {- {{: https://util.unicode.org/UnicodeJsps/list-unicodeset.jsp?a=[:ea=H:]|[:ea=Na:]}All the characters whose East Asian width is either Halfwidth or Narrow} have the same width. Note this class includes ASCII printable characters.}
    {- {{: https://util.unicode.org/UnicodeJsps/list-unicodeset.jsp?a=[:Block=Box_Drawing:]}All the box-drawing characters} have the same width.}
    }
  This is making explicit what Level 2a means; however, we might update the details of Level 2b later to better match our understanding of Level 2a.

- {b Level 3 (the most stable):} Stability under only one assumption that the same graphic cluster will have the same width. This means that the ASCII art will remain visually pleasing in almost all situations. It can even be rendered with a variable-width font.

Unlike most implementations, which are at Level 1, our {{!module:Asai.Tty}terminal backend} strives to achieve Level 2. That means we must not make any assumption about the visual width of the end user's code and must abandon the idea of {i column numbers.} As a result, our terminal backend {i never} shows column numbers and we consider that as a significant improvement. We believe Level 3 is too restricted for terminals because we cannot even show line numbers along with the end user's code. (We cannot assume numbers "10" and "99" have the same visual width at Level 3.)

Note: a fixed-with Unicode font is often technically duospaced, not monospaced, because many CJK characters would occupy a double character width. Thus, we do not say "monospaced".

{1 Raw Bytes as Positions}

All positions are {b byte-oriented.} Here are some popular alternatives which we think are worse:

+ Unicode characters (which may not match user-perceived characters)
+ Unicode grapheme clusters (user-perceived characters; see the {{: https://erratique.ch/software/uuseg}uuseg} library)
+ Column numbers (visual width of a string in display)

It takes at least linear time to count Unicode characters (except when UTF-32 is in use) or Unicode grapheme clusters from raw bytes. Column numbers are even worse because they are not well-defined, as elaborated in the previous section. The only well-defined unit that also admits an efficient implementation is {i raw byte}.

Note: Our LSP prototype does not handle [positionEncoding] yet, and thus an LSP client may be confused about the ranges returned by this library. A proper LSP implementation should negotiate with the client to determine how to represent column numbers (and our current prototype does not). Negotiation to use {raw bytes} can be tricky because "byets" are not a {{: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#positionEncodingKind}predefined encoding scheme} yet.
